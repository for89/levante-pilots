```{r}
library(tidyverse)
library(here)
library(glue)
library(rlang)
library(mirt)

source(here("02_score_data/02_fit_irt/irt_modular.R"), chdir = TRUE)
source(here("02_score_data/02_fit_irt/registry_helper.R"))
```

```{r}
# read in all models in registry
mods <- list_models() |> load_models()

# extract model specifications from filenames
mods_coded <- mods |>
  mutate(file = str_remove(filename, "\\.rds$")) |>
  separate_wider_delim(file, names = c("task_dup", "itemtype", "nfact", "invariance"),
                       delim = "_", cols_remove = FALSE, too_few = "align_start") |>
  select(-task_dup) |>
  mutate(invariance = invariance |> replace_na(""))
  # mutate(nfact = map_int(mod_rec, \(mr) mr@nfact),
  #        itemtype = map_chr(mod_rec, \(mr) mr@itemtype),
  #        invariance_terms = map(mod_rec, \(mr) mr@invariance),
  #        invariance = map_chr(invariance_terms, translate_invariance)) |>
  # select(-filename, -path, -invariance_terms)
```

```{r}
#| eval: false
# anova is slow + not necessary for overall score creation

# reconstruct model objects from model records for overlap_items models
mods_overlap <- mods_coded |>
  filter(subset == "overlap_items") |>
  mutate(mod = map(mod_rec, model_from_record))

# create anova of all multigroup models for each task
task_anova <- mods_overlap |>
  # join in model list from fit_irt_modular.qmd for sequencing models
  left_join(models_multigroup) |>
  arrange(task, model_set, subset, model_order) |>
  select(task, mod, nfact, itemtype, invariance) |>
  # run anova for each task
  nest(task_mods = -task) |>
  mutate(anova = map(task_mods, \(tm) anova_mirt_wrapper(tm$mod))) |>
  # remove model objects and flatten out anova results
  mutate(mod_info = map(task_mods, \(tm) tm |> select(-mod))) |>
  select(task, mod_info, anova) |>
  unnest(c(mod_info, anova)) |>
  # identify each task's best model and compute BIC differences from it
  group_by(task) |>
  mutate(delta_bic = BIC - min(BIC),
         best = delta_bic == 0,
         X2 = replace_na(X2, 0),
         model_type = glue("{itemtype}-{invariance}") |> fct_inorder() |> fct_rev()) |>
  ungroup()

ggplot(task_anova, aes(x = model_type, y = delta_bic,
                       shape = best, color = itemtype, size = as.numeric(best))) +
  facet_wrap(vars(task), scales = "free", ncol = 3) +
  geom_point() +
  coord_flip() +
  scale_size_continuous(guide = FALSE, range = c(1, 2)) +
  scale_colour_ptol() +
  theme(axis.text.y = element_text(size = 6),
        axis.title.y = element_blank())
ggsave(here("02_score_data", "plots", "multigroup_anova.png"), width = 9, height = 5)
```

```{r}
# best by language model for each task
mods_best_language <- mods_coded |>
  filter(model_set == "by_language") |>
  mutate(BIC = map_dbl(mod_rec, BIC)) |>
  group_by(task, subset) |>
  filter(BIC == min(BIC)) |>
  ungroup() |>
  select(-BIC)

# best model on overlapping items for each task
mods_best_overlap <- mods_coded |>
  filter(model_set == "multigroup_site", subset == "overlap_items") |>
  mutate(BIC = map_dbl(mod_rec, BIC)) |>
  group_by(task, subset) |>
  filter(BIC == min(BIC)) |>
  ungroup() |>
  select(-BIC)

# best all items multigroup model for each task (if overlap winner not configural)
mods_best_multigroup <- mods_coded |>
  filter(model_set == "multigroup_site", subset == "all_items",
         invariance != "configural") |>
  semi_join(mods_best_overlap |>
              select(task, itemtype, nfact, invariance))

configural_tasks <- mods_best_overlap |>
  filter(invariance == "configural") |>
  select(task)

# best by language model for each task for which overlap winner is configural
mods_best_configural <- mods_best_language |>
  semi_join(configural_tasks) |>
  mutate(invariance = "configural")

mods_best <- bind_rows(mods_best_multigroup, mods_best_configural)
```

```{r}
mods_best_objs <- mods_best |> mutate(mod = map(mod_rec, model_from_record))

mods_group <- mods_best_objs |>
  filter(model_set == "multigroup_site") |>
  mutate(site = map(mod, \(m) m@Data$groupNames),
         group_models = map(mod, multigroup_extract_groups))

mods_group_rxx <- mods_group |>
  select(site, task, itemtype, nfact, invariance, group_models) |>
  unnest(cols = c("group_models", "site")) |>
  mutate(rxx = map_dbl(group_models, marginal_rxx)) |>
  select(site, task, itemtype, nfact, invariance, rxx)

mods_lang_rxx <- mods_best_objs |>
  filter(model_set == "by_language") |>
  mutate(site = subset |> fct_recode("pilot_leuphana_de" = "de",
                                     "pilot_uniandes_co" = "es",
                                     "pilot_western_ca" = "en")) |>
  mutate(rxx = map_dbl(mod, marginal_rxx)) |>
  select(site, task, itemtype, nfact, invariance, rxx)

task_rxx <- bind_rows(mods_group_rxx, mods_lang_rxx)
# pivot_wider(names_from = "site", values_from = "rxx")
# write_rds(task_rxx_wide, here("02_scoring_outputs", "task_rxx_wide.rds"))
write_rds(task_rxx, here("02_scoring_outputs", "task_rxx.rds"))
```

```{r}
# extract scores from best models
scores_best <- mods_best |>
  mutate(scores = map(mod_rec, scores)) |>
  select(-mod_rec) |>
  unnest(scores)

scores_labeled <- scores_best |>
  mutate(nfact = nfact |> as_factor() |> fct_recode("1D" = "f1"), #"2D" = "2"),
         itemtype = itemtype |> as_factor() |>
           fct_recode("Rasch" = "rasch", "2PL" = "2pl"),
         metric_type = "ability",
         model_class = glue("{model_set} ({subset})"),
         model = glue("{itemtype}-{nfact}-{invariance}")) |>
  select(item_task = task, run_id, metric_type, metric_value = ability,
         model_class, model)

write_rds(scores_labeled, here("02_scoring_outputs/scores/registry_scores.rds"),
          compress = "gz")

# mod_coefs <- \(mod_rec) {
#   model_vals(mod_rec) |>
#     as_tibble() |>
#     filter(group != "GROUP", item != "GROUP") |>
#     select(group, item, name, value) |>
#     pivot_wider(names_from = name, values_from = value) |>
#     mutate(item = str_remove(item, glue("{item_sep}[0-9]+$"))) |>
#     distinct()
# }
# 
# all_coefs <- mods |>
#   mutate(coefs = map(mod_rec, mod_coefs)) |>
#   select(-mod_rec) |>
#   unnest(coefs)
```
